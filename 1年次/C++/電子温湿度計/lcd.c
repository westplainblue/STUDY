
/****************************************************************/
/*                TK210466　　西原　葵                           */
/****************************************************************/





/****************************************************************************************************/
/*		LCD表示ライブラリ	：	lcd.c																	*/
/*																									*/
/*　本ファイルはOLED Display 0.96"ライブラリの本体プログラムである．必ずlcd.hと一緒にBuildする必要がある．	*/
/*　本ライブラリでは，twi.h及びtwi.cを利用しており，これらも同時にBuildする必要がある．					*/
/*　本I2C通信ライブラリは，OLED Display 0.96"がSDA及びSCL端子に接続され，LCDデバイスアドレスは0x78を		*/
/*　想定している．LCDデバイスアドレスを修正する場合は，LCD_ADRSのdefine値を修正すること．					*/
/*																									*/
/*	変更履歴																							*/
/*　識別子	日付			氏名					変更内容													*/
/*　#000		2021.07.26	荒金 匡徳			初版リリース												*/
/****************************************************************************************************/
/* CPU Clock定義																						*/
#define 	F_CPU 16000000UL							/* CPU Clock 16 MHz							*/
/* システム定義のヘッダファイル インクルード															*/
#include 	<avr/io.h>
#include	<util/delay.h>
#include	<stdio.h>
#include	<avr/pgmspace.h>							/* FONTをROM領域から読み出すためのヘッダ		*/

/* ユーザ定義のヘッダファイル インクルード																*/
typedef		unsigned char UCHR;
#include	"twi.h"										/* I2Cドライバ用ヘッダファイル					*/

/* フォントデータの配列定義																			*/
extern	char	fnt[];

/* デバイスアドレス																					*/
#define LCD_ADRS	0x78								/* LCDデバイスのI2Cアドレス					*/

/* プロトタイプ宣言																					*/
void	lcd_init(void);									/* OLED Display 初期化						*/
void	lcd_print( int x, int y, char *str);			/* LCDキャラクタバッファに文字を書き込む		*/
void	lcd_flip();										/* LCDキャラクタバッファをイメージ展開し表示	*/
void	lcd_clr(void);									/* LCDキャラクタ及びイメージバッファをクリア	*/
void	memfill( char *ptr, char data, int length);		/* メモリ Fill 関数							*/

/* LCD表示バッファ																					*/
/* font イメージバッファ（[4行][行上+行下][行当たり16文字][1文字当たり8Byte]								*/
static	char lcd_img[4][2][16][8];						/* OLED 表示イメージバッファ					*/
/* キャラクタイメージバッファASCIIコード(0x20-0x7F）[4行][1行当たり16文字]								*/
static	char lcd_chr[4][16];							/* OLED キャラクタバッファ					*/

/****************************************************************************************************/
/* 関数名：LCD初期化関数		void	lcd_init(void)													*/
/*																									*/
/* 機能　：I2Cバスの初期化,SSD1315の初期化及びLCDキャラクタバッファ（lcd_chr[4][16]），					*/
/*		  表示イメージバッファ(lcd_img[4][2][16][8]）をクリアする										*/
/* 引数　：なし																						*/
/* 戻り値：なし																						*/
/****************************************************************************************************/
void	lcd_init(void){									/* OLED Display 初期化						*/
	twi_init();											/* I2C通信初期化								*/

	twi_start(LCD_ADRS);								/* デバイスアドレスを指定して送信開始			*/
	twi_send(0b00000000);								/* 制御byte Co = 0 (継続) D/C# = 0 (コマンド)	*/
	twi_send(0xAE);										/* 表示 off									*/
	twi_send(0xA8);										/* Multiplex Ratio を64に設定				*/
	twi_send(0b00111111);
	twi_send(0xD3);										/* 表示オフセット：原点のまま					*/
	twi_send(0x00);
	twi_send(0x40);										/* 表示開始行を先頭にセット					*/
	twi_send(0xA0);										/* 表示データ-セグメントデータ間オフセット初期化*/
	twi_send(0xC0);										/* COM 出力スキャン方向設定：順方向			*/
	twi_send(0xDA);										/* COM ピンハードウェア設定					*/
	twi_send(0b00010010);
	twi_send(0x81);										/* コントラスト(明るさ)設定					*/
	twi_send(255);										/* 最大輝度									*/
	twi_send(0xA4);										/* メモリ内のコンテンツ表示ON					*/
	twi_send(0xA6);										/* メモリ内通常表示(1：白/0：黒）				*/
	twi_send(0xD5);										/* 表示クロック設定							*/
	twi_send(0b10000000);
	twi_send(0x2E);										/* スクロール表示無効設定						*/
	twi_send(0x21);										/* メモリのスタートカラムと終了カラムの設定		*/
	twi_send(0);										/* 水平開始位置								*/
	twi_send(127);										/* 水平位置終了位置							*/
	twi_send(0x22);										/* メモリのページアドレス設定					*/
	twi_send(0);										/* 垂直開始位置（0ページ）					*/
	twi_send(7);										/* 垂直終了位置（7ページ）					*/
	twi_send(0x8D);										/* チャージポンプ設定（7.5V)					*/
	twi_send(0x14);
	twi_send(0xAF);										/* 標準モードで Display On					*/
	twi_stop();
	/* 表示メモリクリア																				*/
	memfill(&lcd_chr[0][0],0x20,4*16);					/* キャラクタバッファクリア					*/
	lcd_flip();											/* LCDに空白を出力							*/
}

/****************************************************************************************************/
/* 関数名：LCDクリア関数		void	lcd_clr(void)													*/
/*																									*/
/* 機能　：LCDキャラクタバッファ（lcd_chr[4][16]）及び表示イメージバッファ(lcd_img[4][2][16][8]）			*/
/*		　をクリアする																				*/
/* 引数　：なし																						*/
/* 戻り値：なし																						*/
/* 備考　：LCDキャラクタバッファは空白で，表示イメージバッファは0x00で埋める．								*/
/****************************************************************************************************/
void	lcd_clr(void){
	memfill(&lcd_img[0][0][0][0],0x00,2*4*16*8);		/* 表示イメージバッファクリア					*/
	memfill(&lcd_chr[0][0],0x20,4*16);					/* キャラクタバッファクリア					*/
}

/****************************************************************************************************/
/* 関数名：LCD表示関数		void	lcd_print( int x, int y, char *str)								*/
/*																									*/
/* 機能　：LCDのキャラクタバッファにデータを書き込む．（LCDへの表示はlcd_flip関数をCallしないと行われない）	*/
/*																									*/
/* 引数　：int	x				：　書き込むカラム番号（左から何文字目か）								*/
/*		  int	y				：　書き込む行番号（上から何行目か）									*/
/*		  char	*str			：　書き込むデータの先頭アドレス										*/
/* 戻り値：なし																						*/
/* 備考　：指定する行番号及びカラム番号は，もともと4行（0〜3）16文字（0〜15）を想定しているが，自動改行を	*/
/*		  想定し，例えば(x,y)を(16,0)と指定しても(0,1)と指定したのと同じ結果が得られる．					*/
/*		  また，3行目を超えた場合は0行目に折り返す．よって，(x,y)を（16,3）と指定しても(0,0)と指定したのと	*/
/*		  同じ結果が得られる．																		*/
/*		  書き込むデータはASCIIコードで0x20〜0x7Fの範囲を有効とし，これ以外のコードが出てきた段階で		*/
/*		  キャラクタバッファへの転送を終了する．（NULL終端推奨）											*/
/****************************************************************************************************/
void	lcd_print( int x, int y, char *str){
	y = y + x/16;										/* xが1行の文字数を超えていた場合,改行処理を行う*/
	x %= 16;
	y %= 4;												/* yが3行目を超えた場合は0行目に戻る			*/
	while((*str >= 0x20)&&(*str <= 0x7f)){				/* 次に書き込むデータが範囲内の間処理を行う		*/
		lcd_chr[y][x] = *str;							/* キャラクタバッファに1Byteデータを書き込む	*/
		str++;											/* 元データのポインタを進める					*/
		x++;											/* LCDキャラクタバッファのカラムを進める		*/
		if( x > 15){									/* 1行の文字数をオーバーしたとき				*/
			x = 0;										/* 行の先頭に戻る								*/
			y++;										/* 行を1行下げる								*/
			if(y > 3){									/* 最下行を超えたとき							*/
				y = 0;									/* 先頭行を指定する							*/
			}
		}
	}
}
/****************************************************************************************************/
/* 関数名：LCDフリップ関数	void	lcd_flip(void)													*/
/*																									*/
/* 機能　：LCDキャラクタバッファ（lcd_chr[4][16]）の内容をフォント展開し，LCDに表示する					*/
/*																									*/
/* 引数　：なし																						*/
/*																									*/
/* 戻り値：なし																						*/
/****************************************************************************************************/
void	lcd_flip(void){									/* LCDキャラクタバッファをイメージ展開し表示	*/
	int		ud, line, culm, i, j, k;
	char	*s_ptr = &lcd_chr[0][0];					/* LCDキャラクタバッファアドレス（lcd_chr）	*/
	PGM_P	f_ptr;										/* font データアドレス						*/
	char	*i_ptr;										/* イメージバッファアドレス（lcd_img）			*/

	/* LCD表示キャラクタ情報をフォントデータとして展開する												*/
	while( s_ptr <= &lcd_chr[3][15]){					/* LCDキャラクタバッファの最後までフォント展開	*/
		for( line=0; line<4; line++){					/* 4行分のデータを展開する					*/
			for( culm=0; culm<16; culm++){				/* 各行16文字分のデータを展開する				*/
				f_ptr = &fnt[(*s_ptr-0x20)*0x10];		/* フォントの先頭アドレス取得					*/
				for( ud=0; ud<2; ud++){					/* 上下順にイメージバッファへ展開				*/
					for( i=0; i<8; i++){				/* フォント8Byte を転送						*/
						lcd_img[line][ud][culm][i] = pgm_read_byte(f_ptr);
						i_ptr++;						/* イメージバッファアドレス更新				*/
						f_ptr++;						/* フォントデータアドレス更新					*/
					}
				}
				s_ptr++;								/* LCDキャラクタバッファアドレス更新			*/
			}
		}
	}

	/* フォントデータをSSD1615にI2Cで転送する															*/
	i_ptr = &lcd_img[0][0][0][0];						/* イメージバッファの先頭アドレスをセット		*/
	/* 8行（2行で1文字分の表示となる）分のフォントデータを転送											*/
	for( i=0; i<8; i++){
		twi_start(LCD_ADRS);							/* I2C 通信開始								*/
		twi_send(0b10000000);							/* アドレスデータ送信							*/
		twi_send(0xB0 | i);								/* ページアドレス送信							*/
		twi_stop();										/* 送信終了									*/
		/* 1行（2行で1文字分の表示となる）分のフォントデータを転送										*/
		for( j=0; j<16; j++){							/* 16×8カラムの表示データ送信					*/
			twi_start(LCD_ADRS);						/* I2C 通信開始								*/
			twi_send(0b01000000);						/* 表示データ送信								*/
			/* 1キャラクタ分のフォントを転送															*/
			for( k=0; k<8; k++){						/* 8カラム分の表示データ送信					*/
				twi_send(*i_ptr);						/* 表示データ1カラム転送						*/
				i_ptr++;
			}
			twi_stop();									/* 8カラム分の表示データ送信完了				*/
		}
	}
}

/****************************************************************************************************/
/* 関数名：メモリFill関数		void	memfill( char *ptr, char data, int length)						*/
/*																									*/
/* 機能　：メモリを任意の値で埋める．																	*/
/*																									*/
/* 引数　：char	*ptr			：　Fillするメモリの先頭アドレス										*/
/*		  char	data			：　メモリを埋める値													*/
/*		  int	length			：　メモリを埋めるバイト数												*/
/* 戻り値：なし																						*/
/****************************************************************************************************/
void	memfill( char *ptr, char data, int length){
	int		i;
	for( i=0; i<length; i++){
		*ptr = data;
		ptr++;
	}
}
